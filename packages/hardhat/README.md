# EvidenceVault — Decentralised Evidence Vault

A production-grade ZK-proof-enabled on-chain evidence registry deployed on Base.
Files are encrypted and stored permanently on Arweave (with optional IPFS backup).
Only cryptographic metadata lives on-chain. Ownership is proven via real Groth16 ZK proofs — the secret **never** appears on-chain.

---

## System Architecture

```
┌──────────────────────────────────────────────────────────────────────┐
│                        OFF-CHAIN (Client)                            │
│                                                                      │
│  File ──keccak256──► fileHash                                        │
│  fileHash + secret ──Poseidon──► commitment   (stored on-chain)      │
│  fileHash + secret ──Groth16──► zkProof       (sent to verifyOwnership) │
│                                                                      │
│  Encrypted file ──► Arweave (permanent) + IPFS (optional backup)    │
└────────────────────────────────┬─────────────────────────────────────┘
                                 │ on-chain calls
┌────────────────────────────────▼─────────────────────────────────────┐
│                      EvidenceVault.sol (UUPS Proxy)                  │
│                                                                      │
│  createProof(fileHash, commitment, arweaveTxId, ipfsCid)             │
│  verifyOwnership(fileHash, zkProof, publicInputs) ─────────────────┐ │
│  grantAccess(fileHash, grantee)                                     │ │
│  revokeProof(fileHash)                                              │ │
└─────────────────────────────────────────────────────────────────────│─┘
                                                                      │
┌─────────────────────────────────────────────────────────────────────▼─┐
│              Groth16VerifierWrapper → CommitmentVerifier.sol          │
│              (SnarkJS auto-generated BN254 pairing verifier)          │
│                                                                       │
│  verifyProof(pA, pB, pC, [fileHash_felt, commitment_felt]) → bool     │
└───────────────────────────────────────────────────────────────────────┘
```

---

## ZK Proof Flow (Real — Secret Never Touches Chain)

```
CLIENT SIDE
───────────
1. secret      = secureRandom(32 bytes)       ← STORE THIS SECURELY
2. fileHash    = keccak256(fileBuffer)
3. commitment  = Poseidon(fileHash % p, secret % p)    ← stored on-chain
4. zkProof     = Groth16.prove(fileHash, secret)       ← submitted to verifyOwnership()

Circuit proves: commitment == Poseidon(fileHash, secret)
                WITHOUT revealing secret in publicInputs or calldata.

ON-CHAIN (verifyOwnership)
──────────────────────────
5. Checks publicInputs[0] == stored fileHash      ← binds proof to this specific proof
6. Checks publicInputs[1] == stored commitment    ← binds proof to this specific commitment
7. Calls Groth16Verifier.verifyProof(zkProof, publicInputs)
8. Returns true only if BN254 pairing equations hold
```

---

## File Structure

```
evidence-vault/
├── circuits/
│   └── commitment.circom          ← Poseidon preimage ZK circuit
├── contracts/
│   ├── IEvidenceVault.sol         ← Full interface (events, errors, structs, functions)
│   ├── IZKVerifier.sol            ← Groth16 verifier interface
│   ├── EvidenceVaultStorage.sol   ← Isolated append-only storage + __gap
│   ├── EvidenceVault.sol          ← Main UUPS upgradeable contract
│   ├── Groth16VerifierWrapper.sol ← Adapts SnarkJS verifier to IZKVerifier
│   ├── CommitmentVerifier.sol     ← AUTO-GENERATED by SnarkJS (do not edit)
│   └── test/
│       └── MockVerifier.sol       ← Test helper
├── scripts/
│   ├── deploy.ts                  ← Full deployment (verifier + wrapper + vault)
│   ├── upgrade.ts                 ← Safe UUPS upgrade with storage validation
│   └── zkSetup.ts                 ← Circuit compile, trusted setup, proof generation
├── client/
│   └── sdk.ts                     ← TypeScript SDK (hashing, commitment, proof gen)
├── test/
│   └── EvidenceVault.test.ts      ← Full test suite
├── hardhat.config.ts
└── package.json
```

---

## Quick Start

### 1. Install dependencies

```bash
npm install

# Install circom compiler globally
curl -L https://github.com/iden3/circom/releases/latest/download/circom-linux-amd64 \
  -o /usr/local/bin/circom && chmod +x /usr/local/bin/circom
```

### 2. ZK Trusted Setup (one-time)

```bash
npm run zk:setup
```

This will:
- Compile `commitment.circom` → WASM + R1CS
- Download the Hermez Powers of Tau file
- Run Groth16 phase 2 setup
- Generate `CommitmentVerifier.sol` in `contracts/`

> ⚠️ **Production**: Run a multi-party ceremony with ≥3 independent contributions before deploying to mainnet.

### 3. Compile contracts

```bash
npm run compile
```

### 4. Run tests

```bash
npm test
npm run test:gas    # with gas reporting
npm run test:coverage
```

### 5. Deploy to testnet

```bash
cp .env.example .env
# Fill in DEPLOYER_PRIVATE_KEY, BASE_SEPOLIA_RPC_URL, BASESCAN_API_KEY

MULTISIG=0xYourGnosisSafe npm run deploy:testnet
```

### 6. Generate a proof (CLI)

```bash
FILE=./my-document.pdf SECRET=0x$(openssl rand -hex 32) npm run zk:prove
```

---

## Environment Variables

```bash
# .env
DEPLOYER_PRIVATE_KEY=0x...        # Deployer private key
BASE_RPC_URL=https://mainnet.base.org
BASE_SEPOLIA_RPC_URL=https://sepolia.base.org
BASESCAN_API_KEY=...              # For contract verification
MULTISIG=0x...                    # Gnosis Safe address (receives ownership)
PROXY=0x...                       # For upgrade script
REPORT_GAS=true                   # Enable gas reporting in tests
```

---

## Client SDK Usage

```typescript
import { buildProofInput, generateZKProof, EvidenceVaultClient } from "./client/sdk";
import * as fs from "fs";

const PROXY     = "0x...";
const WASM_PATH = "./build/circuits/commitment_js/commitment.wasm";
const ZKEY_PATH = "./build/circuits/commitment_final.zkey";

// ── 1. Hash file and generate commitment BEFORE uploading ──
const fileBuffer  = fs.readFileSync("./evidence.pdf");
const proofInput  = await buildProofInput(fileBuffer);

console.log("fileHash:  ", proofInput.fileHash);
console.log("commitment:", proofInput.commitment);
// ⚠️  SAVE proofInput.secret to your password manager NOW

// ── 2. Encrypt + upload to Arweave ──
const arweaveTxId = await yourArweaveUpload(encrypt(fileBuffer));

// ── 3. Register on-chain ──
const client = new EvidenceVaultClient(PROXY, signer);
await client.createProof({
  fileHash:    proofInput.fileHash,
  commitment:  proofInput.commitment,
  arweaveTxId,
  ipfsCid: "",  // add later with addBackup()
});

// ── 4. Later: prove ownership WITHOUT revealing secret ──
const bundle  = await generateZKProof(WASM_PATH, ZKEY_PATH, proofInput);
const isOwner = await client.verifyOwnership(proofInput.fileHash, bundle);
// secret was NEVER in any transaction calldata or on-chain state
console.log("Verified:", isOwner); // true

// ── 5. Grant access to an auditor ──
await client.grantAccess(proofInput.fileHash, "0xAuditorAddress");
```

---

## Security Model

### Threat Matrix

| Threat | Mitigation |
|--------|-----------|
| Secret revealed on-chain | `verifyOwnership` uses Groth16 — secret is a private witness, never in calldata |
| Front-running createProof | Commitment is already the Poseidon hash of secret — front-runner gets nothing useful |
| Reentrancy | `nonReentrant` on all state-mutating functions |
| Unauthorized upgrade | `_authorizeUpgrade` is `onlyOwner`; owner should be multisig + timelock |
| Storage collision on upgrade | Append-only layout, `__gap[48]`, `validateUpgrade` enforced in CI |
| DoS via large input | Arweave TxID enforced at exactly 43 bytes; IPFS CID ≤ 128 bytes |
| Invalid field elements | `commitment < BN254_FIELD_SIZE` enforced in `createProof` |
| Proof for wrong commitment | `publicInputs[1]` must match stored commitment in `verifyOwnership` |
| Emergency | `PausableUpgradeable` halts all writes |
| Invalid ZK circuit | Poseidon over BN254 — ZK-native, audit-proven hash function |

### Why Poseidon and not keccak256 in the circuit?

keccak256 inside a SNARK requires ~150,000 R1CS constraints.
Poseidon is designed for ZK and requires only ~220 constraints for 2 inputs.
This makes proof generation fast (~2-5s) and the on-chain verifier cheap (~300k gas).

### Trusted Setup Warning

The `commitment_final.zkey` file is the result of the trusted setup ceremony.
If the ceremony is compromised (toxic waste leaked), someone could forge proofs.

For production:
- Use the official Hermez/Aztec Powers of Tau files (publicly audited)
- Run phase 2 contributions with ≥3 independent parties
- Publish contribution hashes publicly for verification

---

## Gas Estimates (Base Mainnet)

| Function | Estimated Gas |
|----------|--------------|
| `createProof` (first call) | ~120,000 |
| `addBackup` | ~35,000 |
| `revokeProof` | ~28,000 |
| `grantAccess` | ~47,000 |
| `revokeAccess` | ~25,000 |
| `verifyOwnership` (view) | 0 (eth_call) |
| `upgradeTo` | ~38,000 |

---

## Upgrade Safety Rules

When writing `EvidenceVaultV2.sol`:

1. ✅ **DO** append new variables ABOVE `__gap` in `EvidenceVaultStorage`
2. ✅ **DO** decrease `__gap` length by 1 for each new variable
3. ✅ **DO** run `upgrades.validateUpgrade()` in CI before merging
4. ❌ **NEVER** remove existing variables
5. ❌ **NEVER** reorder existing variables
6. ❌ **NEVER** change a variable's type

Example safe V2 addition:
```solidity
// EvidenceVaultStorage.sol
mapping(address => uint256) internal _ownerProofCount;  // existing
address internal _zkVerifier;                            // existing
uint256 public  newFeatureFlag;                          // NEW ← append here
uint256[47] private __gap;                               // was 48, now 47
```

---

## Deployment Checklist

- [ ] Run trusted setup ceremony (≥3 parties for mainnet)
- [ ] `npm run compile` — no errors
- [ ] `npm test` — all tests pass
- [ ] `npm run test:gas` — gas within budget
- [ ] Deploy to Base Sepolia and run full integration test
- [ ] Deploy to Base Mainnet
- [ ] Verify all contracts on Basescan
- [ ] Transfer ownership to Gnosis Safe multisig
- [ ] Wrap multisig with TimelockController (≥48h delay for upgrades)
- [ ] Set up event monitoring (Alchemy webhooks or subgraph)
- [ ] Publish deployment manifest and circuit contribution hashes
